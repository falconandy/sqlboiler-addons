package editor

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"github.com/iancoleman/strcase"

	"github.com/falconandy/sqlboiler-addons/model"
	"github.com/falconandy/sqlboiler-addons/parser"
)

type Builder struct {
	FileExt string

	entitiesDir string
}

func NewBuilder(entitiesDir string) *Builder {
	return &Builder{
		entitiesDir: entitiesDir,
		FileExt:     ".go",
	}
}

func (b *Builder) Build(writer io.Writer) error {
	w := mustWriter{w: writer}

	items, err := ioutil.ReadDir(b.entitiesDir)
	if err != nil {
		return err
	}

	entities := make([]*model.Entity, 0, len(items))
	for _, item := range items {
		if b.skipFile(item.Name()) {
			continue
		}

		entityPath := filepath.Join(b.entitiesDir, item.Name())
		entity, err := parser.ParseEntityFile(entityPath)
		if err != nil {
			log.Printf("Skip %s: %v\n", entityPath, err)
			continue
		}
		entities = append(entities, entity)
	}

	fieldPackageNames := make(map[string]bool)
	for _, entity := range entities {
		for _, f := range entity.Fields {
			dotIndex := strings.IndexRune(f.Type, '.')
			if dotIndex >= 0 {
				packageName := f.Type[:dotIndex]
				fieldPackageNames[packageName] = true
			}
		}
	}

	for i, entity := range entities {
		if i == 0 {
			w.Writeln(`// Code generated by SQLBoiler addon. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
`)
			w.Writeln(fmt.Sprintf("package %s", entity.Package))

			if len(fieldPackageNames) > 0 {
				w.Writeln("\nimport (")
				w.Writeln("\t\"context\"")
				if fieldPackageNames["time"] {
					w.Writeln("\t\"time\"")
				}

				w.Writeln("")

				if fieldPackageNames["null"] {
					w.Writeln("\t\"github.com/volatiletech/null\"")
				}
				w.Writeln("\t\"github.com/volatiletech/sqlboiler/boil\"")
				w.Writeln(")")
			}

			b.writeBaseEditor(w)
		}
		b.buildEntity(w, entity)
	}

	return nil
}

func (b *Builder) skipFile(name string) bool {
	if !strings.HasSuffix(name, b.FileExt) {
		return true
	}

	name = strings.TrimSuffix(name, b.FileExt)

	switch name {
	case "boil_queries", "boil_table_names", "boil_types", "psql_upsert":
		return true
	case "boil_editors":
		return true
	default:
		return false
	}
}

func (b *Builder) writeBaseEditor(w mustWriter) {
	w.Writeln(`
type editor struct {
	columns []string
}

func (e *editor) addColumn(column string) {
	for _, col := range e.columns {
		if col == column {
			return
		}
	}
	e.columns = append(e.columns, column)
}`)
}

func (b *Builder) buildEntity(w mustWriter, entity *model.Entity) {
	b.writeEditorType(w, entity)
	b.writeEditorSetters(w, entity)
	b.writeEditorFunction(w, entity, entity.InsertSignature)
	b.writeEditorFunction(w, entity, entity.UpdateSignature)
}

func (b *Builder) writeEditorType(w mustWriter, entity *model.Entity) {
	w.Writeln(fmt.Sprintf(`
type %[1]sE struct {
	editor
	S *%[1]s
}

func (o *%[1]s) E() *%[1]sE {
	return &%[1]sE{S: o}
}

func %[1]sEditor() *%[1]sE {
	return &%[1]sE{S: &%[1]s{}}
}`, entity.Name))
}

func (b *Builder) writeEditorSetters(w mustWriter, entity *model.Entity) {
	for _, f := range entity.Fields {
		w.Writeln(fmt.Sprintf(`
func (e *%[1]sE) Set%[2]s(%[3]s %[4]s) *%[1]sE {
	e.S.%[2]s = %[3]s
	e.addColumn(%[1]sColumns.%[2]s)
	return e
}`, entity.Name, f.Name, strcase.ToLowerCamel(f.Name), f.Type))
	}
}

func (b *Builder) writeEditorFunction(w mustWriter, entity *model.Entity, signatureLines []string) {
	w.Writeln("")

	comments, rawSignature := signatureLines[:len(signatureLines)-1], signatureLines[len(signatureLines)-1]
	for _, comment := range comments {
		w.Writeln(comment)
	}
	signature, ok := parser.ParseFunctionSignature(rawSignature)
	if !ok {
		return
	}
	w.Write(fmt.Sprintf("func (e *%sE) %s(", entity.Name, signature.Name))

	var arguments []string
	var pars []string
	for _, p := range signature.Parameters {
		if p.Type == "boil.Columns" && len(p.Names) == 1 {
			arguments = append(arguments, "boil.Whitelist(e.columns...)")
		} else {
			pars = append(pars, fmt.Sprintf("%s %s", strings.Join(p.Names, ", "), p.Type))
			arguments = append(arguments, p.Names...)
		}
	}
	w.Write(strings.Join(pars, ", ") + ")")
	if len(signature.Return) > 0 {
		w.Write(" " + signature.Return)
	}
	w.Writeln(" {")
	w.Writeln(fmt.Sprintf("\treturn e.S.%s(%s)", signature.Name, strings.Join(arguments, ", ")))
	w.Writeln("}")
}
